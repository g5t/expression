import ipywidgets as widgets
from IPython.display import display
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap
from mpl_toolkits.axes_grid1.inset_locator import inset_axes
import json
import pandas as pd
from matplotlib.colors import LogNorm
from mpl_toolkits.axes_grid1 import make_axes_locatable
from matplotlib.colors import LogNorm

import warnings

# Ignore UserWarnings generated by ipympl about tight_layout
warnings.filterwarnings('ignore', message="This figure includes Axes that are not compatible with tight_layout, so results might be incorrect.")

# Your widget or plotting code goes here



class GameHistoryVisualizer:
    def __init__(self, data_dicts):

        self.data_dicts = data_dicts

        self.data_subset = []
        self.p_hand_subset = []
        self.p_energy_subset = []
        self.n_hand_subset = []
        self.n_energy_subset = []
        for data_dict in data_dicts:
            self.data_subset.append(data_dict["score"])
            self.p_hand_subset.append(data_dict["positive_hand_size"])
            self.p_energy_subset.append(data_dict["positive_energy_spent"])
            self.n_hand_subset.append(data_dict["negative_hand_size"])
            self.n_energy_subset.append(data_dict["negative_energy_spent"])

        self.cmap = LinearSegmentedColormap.from_list(
            'rwb', [(1, 0, 0), (1, 1, 1), (0, 0, 1)])
        self.max_turns = max(len(score_history) for score_history in self.data_subset)
        self.n_runs = len(self.data_subset)

        self.subset_max_turns = self.max_turns
        self.data_subset = None
        self.stored_min_turn = None
        self.stored_max_turn = None
        self.stored_positive_checkbox = None
        self.stored_negative_checkbox = None

        self.turn_range = None
        self.run_range = None

        self.ax_inset_top = None
        self.ax_inset_bottom = None

        self.cbar_ph = None
        self.cbar_pe = None
        self.cbar_nh = None
        self.cbar_ne = None

        self.positive_checkbox = True
        self.negative_checkbox = True

    def get_color(self, value):
        normalized_value = (value + 1) / 2
        return self.cmap(normalized_value)

    def limit_subset(self, turn_range):

        start_turn, end_turn = turn_range
        if self.stored_min_turn is None or self.stored_max_turn is None or self.data_subset is None or self.stored_positive_checkbox or self.stored_negative_checkbox:
            calculate = True
        else:
            if self.stored_min_turn == start_turn and self.stored_max_turn == end_turn and self.positive_checkbox == self.stored_positive_checkbox and self.negative_checkbox == self.stored_negative_checkbox:
                calculate = False
            else:
                calculate = True

        if calculate:
            self.data_subset = []
            self.p_hand_subset = []
            self.p_energy_subset = []
            self.n_hand_subset = []
            self.n_energy_subset = []
            for data_dict in self.data_dicts:
                if not start_turn <= len(data_dict["score"]) <= end_turn:
                    continue

                if not self.positive_checkbox:
                    if data_dict["score"][-1] < 0:
                        continue

                if not self.negative_checkbox:
                    if data_dict["score"][-1] > 0:
                        continue

                self.data_subset.append(data_dict["score"])
                self.p_hand_subset.append(data_dict["positive_hand_size"])
                self.p_energy_subset.append(data_dict["positive_energy_spent"])
                self.n_hand_subset.append(data_dict["negative_hand_size"])
                self.n_energy_subset.append(data_dict["negative_energy_spent"])

            #self.data_subset = [h for h in self.data if start_turn <= len(h) <= end_turn]
            self.stored_min_turn = start_turn
            self.stored_max_turn = end_turn
            self.stored_positive_checkbox = self.positive_checkbox
            self.stored_negative_checkbox = self.negative_checkbox

            if len(self.data_subset) > 0:
                self.subset_max_turns = max(len(score_history) for score_history in self.data_subset)

    def plot_subset(self, initial=False):
        start_turn, end_turn = self.turn_range
        start_run, end_run = self.run_range

        self.limit_subset(self.turn_range)

        if len(self.data_subset) == 0:
            return

        #data_set = self.data[start_run:end_run]
        data_set = self.data_subset
        longest_history = max(len(score_history) for score_history in data_set)

        positive_win_lengths, negative_win_lengths = [], []
        for score_history in data_set:
            length = len(score_history)
            length_frac = 1 - (length / longest_history) * 0.4
            color_sign = 1 if score_history[-1] > 0 else -1
            color = self.get_color(color_sign * length_frac)

            if score_history[-1] > 0:
                positive_win_lengths.append(length)
            else:
                negative_win_lengths.append(length)

            self.axs[1,0].plot(score_history, color=color, alpha=0.6)

        self.axs[1,0].set_xlabel("Turns")
        self.axs[1,0].set_ylabel("Score")

        self.axs[1,0].plot([0, longest_history], [100, 100], "--k")
        self.axs[1,0].plot([0, longest_history], [-100, -100], "--k")

        self.axs[1,0].set_ylim([-115, 115])

        # transform to n turn for that player
        positive_win_lengths = list(np.array(positive_win_lengths)/2)
        negative_win_lengths = list((np.array(negative_win_lengths ) + 1)/2)

        # Calculate the length of each list
        lengths_set1 = positive_win_lengths
        lengths_set2 = negative_win_lengths

        if len(lengths_set1) > 0:
            max_lengths_set1 = max(lengths_set1)
        else:
            max_lengths_set1 = 0

        if len(lengths_set2) > 0:
            max_lengths_set2 = max(lengths_set2)
        else:
            max_lengths_set2 = 0

        bins = np.arange(0, max(max_lengths_set1, max_lengths_set2) + 2) - 0.5

        hist1, edges = np.histogram(lengths_set1, bins=bins)
        hist2, edges = np.histogram(lengths_set2, bins=bins)

        # Plot the first dataset as positive
        self.axs[1,1].bar(bins[:-1] + 0.5, hist1, width=1, color='blue', label='Set 1', align='center', alpha=0.8)

        # Plot the second dataset as negative
        self.axs[1,1].bar(bins[:-1] + 0.5, -hist2, width=1, color='red', label='Set 2', align='center', alpha=0.8)

        max_y_value = max([max(hist1), max(hist2)])
        self.axs[1,1].set_ylim([-max_y_value, max_y_value])

        self.axs[1,1].set_xlabel('Winning turn')
        self.axs[1,1].set_ylabel('Frequency')
        #self.axs[1,1].set_title('Turn of win')
        #self.axs[1,0].legend()

        ticks = self.axs[1,1].get_yticks()
        self.axs[1,1].set_yticks(ticks, [str(abs(tick)) for tick in ticks])

        self.axs[1,1].stairs(hist1 - hist2, edges, color="black", alpha=0.5)
        # self.axs[1].grid(True, which='both', linestyle='--', linewidth=0.5)
        # self.axs[1].set_xticks(np.arange(0, max(lengths_set1 + lengths_set2) + 1))  # Setting x-ticks to show every possible list length

        positive_win_rate = len(positive_win_lengths) / len(data_set)
        negative_win_rate = len(negative_win_lengths) / len(data_set)
        """
        labels = (
            f'Positive wins {100 * positive_win_rate:.1f} %',
            f"Negative wins {100 * negative_win_rate:.1f} %"
        )
        """
        labels = (
            f"{100 * positive_win_rate:.1f} %",
            f"{100 * negative_win_rate:.1f} %"
        )
        sizes = [positive_win_rate, negative_win_rate]

        #self.axs[2].pie(sizes, labels=labels, colors=["blue", "red"])

        if self.ax_inset_top is None or self.ax_inset_bottom is None:
            self.ax_inset_top = inset_axes(self.axs[1, 1], width="35%", height="35%", loc='upper right')
            self.ax_inset_bottom = inset_axes(self.axs[1, 1], width="35%", height="35%", loc='lower right')

            self.ax_inset_top.axis("off")
            self.ax_inset_bottom.axis("off")

        if positive_win_rate > negative_win_rate:
            self.ax_inset_top.pie(sizes, labels=labels, colors=["blue", "red"])
            self.ax_inset_bottom.axis("off")
        else:
            self.ax_inset_bottom.pie(sizes, labels=labels, colors=["blue", "red"])
            self.ax_inset_top.axis("off")

        self.cbar_ph = self.plot_2D_heat(self.fig, self.axs[0,0], self.p_hand_subset, "Hand size", cax=self.cbar_ph)
        self.cbar_pe = self.plot_2D_heat(self.fig, self.axs[0,1], self.p_energy_subset, "Energy spent", cax=self.cbar_pe)

        self.cbar_nh = self.plot_2D_heat(self.fig, self.axs[2, 0], self.n_hand_subset, "Hand size", cax=self.cbar_nh)
        self.cbar_ne = self.plot_2D_heat(self.fig, self.axs[2, 1], self.n_energy_subset, "Energy spent", cax=self.cbar_ne)

        if initial:
            plt.show()

    def plot_2D_heat(self, fig, ax, lists, ylabel, cax):

        # Assuming 'hand_sizes' contains your lists of hand sizes
        hand_sizes = lists

        # Convert the list of lists into a DataFrame for easier manipulation
        df = pd.DataFrame(hand_sizes)

        # Creating a long-format DataFrame where each row is a (turn, hand size) pair
        # Note: We don't replace NaNs with zeros here to avoid introducing artificial data
        df_long = df.melt(var_name='Turn', value_name='Hand Size').dropna()

        # Creating a pivot table to count the frequency of each (turn, hand size) combination
        pivot_table = df_long.pivot_table(index='Hand Size', columns='Turn', aggfunc='size', fill_value=0)

        # Plotting the heatmap
        chosen_colormap = 'viridis'
        min_nonzero = np.min(np.ma.masked_equal(pivot_table.values, 0))

        im = ax.imshow(pivot_table, cmap=chosen_colormap,
                       norm=LogNorm(vmin=min_nonzero, vmax=pivot_table.max().max()),
                       aspect='auto')

        ax.invert_yaxis()

        # Create an axes on the right side of ax. The width of cax will be 5%
        # of ax and the padding between cax and ax will be fixed at 0.05 inch.
        divider = make_axes_locatable(ax)

        if cax is not None:
            fig.delaxes(cax)

        cax = divider.append_axes("right", size="5%", pad=0.05)

        # Add colorbar
        fig.colorbar(im, cax=cax)

        ax.set_xlabel('Turn Number')
        ax.set_ylabel(ylabel)



        # Setting the ticks to match the hand sizes and turns
        #ax.set_xticks(range(len(df.columns)))
        ax.set_yticks(range(len(pivot_table.index)))
        #ax.set_xticklabels(df.columns)
        ax.set_yticklabels(pivot_table.index)

        return cax

    def clear_plot(self):
        self.axs[0, 0].clear()
        self.axs[1, 0].clear()
        self.axs[2, 0].clear()
        self.axs[0, 1].clear()
        self.axs[1, 1].clear()
        self.axs[2, 1].clear()

        if self.ax_inset_top is not None:
            self.ax_inset_top.clear()

        if self.ax_inset_bottom is not None:
            self.ax_inset_bottom.clear()

        if self.cbar_ph is not None:
            self.cbar_ph.clear()

        if self.cbar_pe is not None:
            self.cbar_pe.clear()

        if self.cbar_nh is not None:
            self.cbar_nh.clear()

        if self.cbar_ne is not None:
            self.cbar_ne.clear()

    def setup_widget(self):
        self.fig, self.axs = plt.subplots(3, 2, figsize=(9.5, 9), tight_layout=True)

        turns_slider = widgets.IntRangeSlider(
            value=[0, self.max_turns],
            min=0,
            max=self.max_turns,
            step=1,
            description='Turn Range:',
            continuous_update=False
        )

        initial_run_value = min([self.n_runs, 500])
        runs_slider = widgets.IntRangeSlider(
            value=[0, initial_run_value],
            min=0,
            max=self.n_runs,
            step=1,
            description='Run Range:',
            continuous_update=False
        )

        check_positive = widgets.Checkbox(
            value=True,  # Initial state of the checkbox
            description='Positive won',  # Text displayed next to the checkbox
            disabled=False  # Whether the checkbox is interactive or grayed out
        )

        check_negative = widgets.Checkbox(
            value=True,  # Initial state of the checkbox
            description='Negative won',  # Text displayed next to the checkbox
            disabled=False  # Whether the checkbox is interactive or grayed out
        )

        def update_plot_turn(change):
            self.clear_plot()

            self.turn_range = change.new
            self.plot_subset()

        def update_plot_run(change):
            self.clear_plot()

            self.run_range = change.new
            self.plot_subset()

        def update_plot_positive(change):
            self.clear_plot()

            self.positive_checkbox = change.new
            self.plot_subset()

        def update_plot_negative(change):
            self.clear_plot()

            self.negative_checkbox = change.new
            self.plot_subset()

        display(widgets.HBox([turns_slider, runs_slider, check_positive, check_negative]))
        turns_slider.observe(update_plot_turn, names='value')
        runs_slider.observe(update_plot_run, names='value')
        check_positive.observe(update_plot_positive, names='value')
        check_negative.observe(update_plot_negative, names='value')

        self.run_range = 0, initial_run_value
        self.turn_range = 0, self.max_turns

        self.plot_subset(initial=True)


if __name__ == "__main__":
    # Load your data here; replaced with a placeholder
    with open('data.json', 'r') as f:
        loaded_data = json.load(f)

    loaded_lists = []
    for data_dict in loaded_data:
        loaded_lists.append(data_dict["score"])

    visualizer = GameHistoryVisualizer(loaded_lists)
    visualizer.setup_widget()
